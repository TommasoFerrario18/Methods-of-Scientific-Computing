\chapter{Progetto 1 bis: Mini libreria per sistemi lineari}
\section{Introduzione}
Per la realizzazione della libreria contenente i metodi per la risoluzione di
sistemi lineari, è stato scelto di utilizzare \href{https://julialang.org/}{\textbf{Julia}},
un linguaggio di programmazione open-source, sviluppato per ottenere prestazioni
elevate e con una sintassi simile a quella di Python e MATLAB. Essendo concepito
per la manipolazione efficace del calcolo scientifico, offre una vasta gamma di
librerie per la gestione di matrici e vettori.

In particolare, per lo sviluppo di questo progetto sono state utilizzate due
librerie della Standard Library di Julia:
\begin{itemize}
    \item \textbf{LinearAlgebra}: fornisce funzioni per la manipolazione di
          matrici e vettori.
    \item \textbf{SparseArrays}: fornisce funzioni per la gestione di matrici sparse.
\end{itemize}

L'impiego di quest'ultima libreria è stato fondamentale per ridurre l'occupazione
di memoria, in quanto le matrici utilizzate negli esperimenti sono matrici sparse.
Nello specifico, sono state utilizzate le seguenti matrici sparse:
\begin{itemize}
    \item \textbf{spa1}: matrice di dimensione 1000x1000 con 182,434 elementi non nulli.
    \item \textbf{spa2}: matrice di dimensione 3000x3000 con 1,633,298 elementi non nulli.
    \item \textbf{vem1}: matrice di dimensione 1681x1681 con 13,385 elementi non nulli.
    \item \textbf{vem2}: matrice di dimensione 2601x2601 con 21,225 elementi non nulli.
\end{itemize}

Per permettere la riproducibilità degli esperimenti, vogliamo riportare di seguito
le caratteristiche del sistema utilizzato per la realizzazione della libreria e
per l'esecuzione degli esperimenti. Tutti gli esperimenti sono stati eseguiti su
un computer con le seguenti caratteristiche:
\begin{itemize}
    \item CPU: Intel Core i5-1135G7
    \item RAM: 16 GB
    \item Sistema Operativo: Windows 11
    \item Julia: versione 1.10.2
\end{itemize}
\section{Struttura della libreria}
La libreria realizzata è composta da tre moduli principali:
\begin{itemize}
    \item \textbf{IterativeMethods}: contiene i metodi iterativi per la risoluzione
          di sistemi lineari.
    \item \textbf{DirectMethods}: contiene i metodi diretti per la risoluzione
          di sistemi lineari.
    \item \textbf{Utils}: contiene le funzioni di utilità per la manipolazione
          di matrici e vettori.
\end{itemize}

\subsection{Utils}
Nel modulo \textbf{Utils} sono presenti le funzioni per svolgere compiti di
utilità. Tra queste troviamo:
\begin{itemize}
    \item \textbf{read\_sparse\_matrix}: funzione per la lettura di una matrice
          da file in formato \textbf{.mtx}. Tale funzione restituisce una matrice
          sparsa.
    \item \textbf{check\_sizes}: funzione per il controllo delle dimensioni di
          una matrice e del vettore dei termini noti.
\end{itemize}
\subsection{DirectMethods}
Nel modulo \textbf{DirectMethods} è presente il metodo che effettua la risoluzione
di un sistema lineare in cui la matrice è triangolare inferiore, tramite il
metodo di sostituzione in avanti.

Di seguito riportiamo lo pseudocodice del metodo \textbf{forward\_substitution}:
\begin{verbatim}
function forward_substitution(A, b)
    n = size(A, 1)
    x = zeros(n)
    x[1] = b[1] / A[1, 1]
    for i in 2
        x[i] = (b[i] - dot(A[i, 1], x[1])) / A[i, i]
    end
    return x
end
\end{verbatim}
Questo metodo è stato implementato poiché nel metodo di risoluzione di Gauß-Seidel,
per cui la regola di aggiornamento è la seguente:
\begin{equation}
    x^{(k+1)} = x^{(k)} + P^{-1}(b - Ax^{(k)})
\end{equation}
con $P$ è una matrice triangolare inferiore, prevede il calcolo di una matrice
inversa. Dato che tale operazione è computazionalmente costosa, possiamo evitare
di calcolare la matrice inversa e al suo posto risolvere il seguente sistema
lineare:
\begin{equation}
    Py = b - Ax^{(k)}
\end{equation}
dove $y$ è il vettore che otteniamo risolvendo il sistema lineare con il metodo
della sostituzione in avanti. In questo modo, possiamo calcolare la soluzione
$x^{(k+1)}$ come:
\begin{equation}
    x^{(k+1)} = x^{(k)} + y
\end{equation} 

\subsection{IterativeMethods}
Nel modulo \textbf{IterativeMethods} sono presenti i metodi iterativi per la
risoluzione di sistemi lineari. In particolare, sono stati implementati i seguenti
metodi:
\begin{itemize}
    \item \textbf{Jacobi}: metodo di Jacobi per la risoluzione di sistemi lineari.
    \item \textbf{GaussSeidel}: metodo di Gauß-Seidel per la risoluzione di
          sistemi lineari.
    \item \textbf{Gradient}: metodo del gradiente per la risoluzione di sistemi
          lineari.
    \item \textbf{ConjugateGradient}: metodo del gradiente coniugato per la
          risoluzione di sistemi lineari.
\end{itemize}

Tutti i metodi implementati utilizzano come criterio di arresto il confronto del
residuo riscalato, calcolato come:
\begin{equation}
    \frac{\|b - Ax^{(k)}\|}{\|b\|}
\end{equation}
dove $x^{(k)}$ è la soluzione al passo $k$ e $b$ è il vettore dei termini noti.
La tolleranza per questo confronto è un valore fornito dall'utente.

Inoltre, per evitare cicli infiniti, è possibile specificare un numero massimo
di iterazioni. Il valore predefinito è fissato a 20000 iterazioni.

\section{Risultati sperimentali}
Implementati i metodi, si è proceduto con la valutazione delle prestazioni di
ciascuno di essi. In particolare, sono stati eseguiti degli esperimenti sulle
matrici precedentemente descritte, utilizzando come vettore dei termini noti il
risultato della moltiplicazione tra la matrice e un vettore di 1 di dimensione
pari al numero di righe della matrice. Oltre a questo, i metodi sono stati testati
al variare della tolleranza, utilizzando i valori $10^{-4}$, $10^{-6}$, $10^{-8}$
e $10^{-10}$.

Per quanto riguarda le misurazioni dei tempi di esecuzione e l'occupazione di
memoria, sono state utilizzate la funzione \textbf{time}, invocata prima e dopo
l'esecuzione del codice, e la macro \textbf{@allocated} per misurare l'occupazione
di memoria. Quest'ultima restituisce la quantità di memoria allocata in byte.


\subsection{Metodo di Jacobi}
\subsection{Metodo di Gauß-Seidel}
\subsection{Metodo del gradiente}
\subsection{Metodo del gradiente coniugato}